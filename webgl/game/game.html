<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - io - scene loader [blender]</title>
		<meta charset="utf-8">
		<meta name="viewport_minigame" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#000;
				color:#fff;
				padding:0;
				margin:0;
				overflow:hidden;
				font-family:georgia;
				text-align:center;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				z-index:100;
			}

			#progress {
				color:red;
				top:7em;
				width: 100%;
				font-size:3em;
				font-variant:small-caps;
				font-weight:bold;
				position:absolute;
				z-index:100;
				text-align: center;
				text-shadow: #000 0px 0px 10px;
				display:none;
			}

			#start {
				color:#fff;
				text-shadow: #000 0px 0px 2px;
				padding:0.1em 0.3em;
				width:3em;
				text-align: center;
				display:none;
			}

			.shadow {
				-moz-box-shadow: 0px 0px 5px #000;
				-webkit-box-shadow: 0px 0px 5px #000;
				box-shadow: 0px 0px 5px #000;
			}

			#progressbar {
				text-align: center;
				background: white;
				width: 250px;
				height: 10px;
			}

			#bar {
				background:#d00;
				width:50px;
				height:10px;
			}

			.enabled {
				color: lime!important;
				cursor:pointer;
			}

			.enabled:hover {
				text-shadow: #0f0 0px 0px 5px !important;
			}

			.disabled {
				background:gray;
				cursor:default;
			}

			a { color:red }
			canvas { pointer-events:none; z-index:10; }

			#scene_explorer {
				background:transparent;
				color:#fff;
				width:200px;
				position:absolute;
				text-align:left;
				top:0px;
				z-index:200;
				overflow:auto;
			}

			#section_exp {
				background:rgba(0,0,50,0.5);
				padding:0.5em 0;
				display:none;
			}

			#scene_explorer h3 {
				font-size:1em;
				padding:0;
				margin:0;
				color:orange;
			}

			#scene_explorer a {
				color:#555;
				font-weight:bold;
				text-decoration:none;
				font-size:1.2em;
				font-family:Monospace;
			}
			#scene_explorer a:hover {
				background:#555;
				color:rgba(0,0,50,1);
			}

			#g_blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}

			.part {
				display:none;
				padding:0 0 0.5em 2em;
			}

        #cursor {
          background:transparent;
          color:#ff;
          position: fixed;
          top: 50%;
          left: 50%;
          width: 50;
          height: 50;
          margin-top: -25px;
          margin-left: -25px;
          text-align:center;
          z-index:300;
        }
		</style>
	</head>

	<body>

         <!--Viewport for the mini game-->
        <div id="viewport_minigame" style="position:fixed; z-index:-1; top:0; left:0; bottom:0; right:0;"></div>

		<script src="../../libs/three.js/three.js"></script>
		<script src="../../libs/three.js/Detector.js"></script>
		<script src="../../libs/three.js/Stats.js"></script>
		<script src="../../libs/three.js/controls/PointerLockControls.js"></script>
		<script src="../../libs/PhysicsSceneLoader.js"></script>
		<script src="../../tools/helpers/AxisHelper.js"></script>
	    <script type="text/javascript" src="../../libs/physijs/physi.js"></script>
		<script src="coincoin.js"></script>
        <script src="minigame.js"></script>
	
        <!--Dependencies for minigame-->
        <script type="text/javascript" src='../../libs/threex/THREEx.WindowResize.js'></script>
        <script type="text/javascript" src="../../libs/threex/THREEx.screenshot.js"></script>
        <script type="text/javascript" src="../../libs/threex/THREEx.FullScreen.js"></script>
        <script type="text/javascript" src="../../libs/stats.js"></script>
        <script type="text/javascript" src="../../libs/imageprocessing.js"></script>
        <script type="text/javascript" src="../../libs/dat.gui/dat.gui.js"></script>
        <script type="text/javascript" src="../../libs/augmentedgesture.js"></script>

		<div id="info">
			<a href="http://threejs.org">three.js</a> - scene loader test [blender]
            <p></p>
		</div>

		<div id="scene_explorer">
			<a id="plus_exp" href="#">[+]</a>
			<div id="section_exp"></div>
		</div>

        <div id="cursor">o</div>

		<div id="progress">
			<span id="message">Loading ...</span>

			<center>
				<div id="progressbar" class="shadow"><div id="bar" class="shadow"></div></div>
                <div id="g_blocker">
				<div id="start" class="disabled">Start</div>
                </div>
			</center>
		</div>

    	<div id="g_blocker"> </div>



		<script>

	
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

	        Physijs.scripts.worker = '../../libs/physijs/physijs_worker.js';
	        Physijs.scripts.ammo = '../../libs/physijs/examples/js/ammo.js';

			var g_container,stats;

			var g_camera, g_scene, g_loaded;
            var g_physicsObjects;
			var g_renderer;

			var g_mesh, g_zmesh, g_geometry;

			var g_mouseX = 0, g_mouseY = 0;

			var g_windowHalfX = window.innerWidth / 2;
			var g_windowHalfY = window.innerHeight / 2;

            // Mouse/Keyboard control
			var g_controls, g_time = Date.now();
            // Object pointed by mouse
			var g_ray;
            var g_debug = true;


            /* ======================== INIT POINTERLOCK ==================== */

			var g_blocker = document.getElementById( 'g_blocker' );
			var g_instructions = document.getElementById( 'start' );
			// http://www.html5rocks.com/en/tutorials/pointerlock/intro/
			var g_havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

			if ( g_havePointerLock ) {

				var element = document.body;

				var pointerlockchange = function ( event ) {

					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

						g_controls.enabled = true;

						g_blocker.style.display = 'none';

					} else {

						g_controls.enabled = false;

						g_blocker.style.display = '-webkit-box';
						g_blocker.style.display = '-moz-box';
						g_blocker.style.display = 'box';

						g_instructions.style.display = '';

					}

				}

				var pointerlockerror = function ( event ) {

					g_instructions.style.display = '';

				}

				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

				document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

				g_instructions.addEventListener( 'click', function ( event ) {

					g_instructions.style.display = 'none';

					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

					if ( /Firefox/i.test( navigator.userAgent ) ) {

						var fullscreenchange = function ( event ) {

							if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

								document.removeEventListener( 'fullscreenchange', fullscreenchange );
								document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

								element.requestPointerLock();
							}

						}

						document.addEventListener( 'fullscreenchange', fullscreenchange, false );
						document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

						element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

						element.requestFullscreen();

					} else {

						element.requestPointerLock();

					}

				}, false );

			} else {

				g_instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

			}


            // adding 3D sound to the world
			var g_Sound = function ( sources, radius, volume ) {

				var audio = document.createElement( 'audio' );

				for ( var i = 0; i < sources.length; i ++ ) {
					var source = document.createElement( 'source' );
					source.src = sources[ i ];

					audio.appendChild( source );
				}

				this.position = new THREE.Vector3();

				this.play = function () {
					audio.play();
				}

				this.update = function ( g_controls ) {
					var distance = this.position.distanceTo( g_controls.getPosition() );
					if ( distance <= radius ) {
						audio.volume = volume * ( 1 - distance / radius );
					} else {
						audio.volume = 0;
					}
				}
			}
			
			var game_sound;


			g_init();
			g_animate();

			function $( id ) {

				return document.getElementById( id );

			}

			function g_handleUpdate( result, pieces ) {
				refreshSceneView( result );
				//g_renderer.initWebGLObjects( result.g_scene );

				var m, material, count = 0;
				for ( m in result.materials ) {
					material = result.materials[ m ];
					if ( ! ( material instanceof THREE.MeshFaceMaterial ) ) {
						if( !material.program ) {
							g_renderer.initMaterial( material, result.scene.__lights, result.scene.fog );
							count += 1;
							if( count > pieces ) {
								break;
							}
						}
					}
				}
			}

			function g_init() {

				g_container = document.createElement( 'div' );
				document.body.appendChild( g_container );

				var loadScene = g_createLoadScene();

				g_camera = loadScene.camera;
				g_scene = loadScene.scene;


				g_renderer = new THREE.WebGLRenderer();
				g_renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				g_renderer.domElement.style.position = "relative";
				g_container.appendChild( g_renderer.domElement );


				g_controls = new THREE.PointerLockControls( g_camera );
				g_scene.add( g_controls.getObject() );
                console.log(g_controls);

				g_ray = new THREE.Raycaster();
				g_ray.ray.direction.set( 0, -1, 0 );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.right = '0px';
				stats.domElement.style.zIndex = 100;
				g_container.appendChild( stats.domElement );
				

				game_sound = new g_Sound( [ '../sounds/minigame_background.ogg' ], 50, 1 );
				game_sound.position.set(0, 10, 0);
				game_sound.play();

				$( "start" ).addEventListener( 'click', g_onStartClick, false );

				var callbackProgress = function( progress, result ) {

					var bar = 250,
						total = progress.total_models + progress.total_textures,
						g_loaded = progress.loaded_models + progress.loaded_textures;

					if ( total )
						bar = Math.floor( bar * g_loaded / total );

					$( "bar" ).style.width = bar + "px";

					count = 0;
					for ( var m in result.materials ) count++;

					g_handleUpdate( result, Math.floor( count/total ) );

				}

				var callbackFinished = function( result ) {

                    console.log(result);

                    g_loaded = result;
                    g_physicsObjects = result.physicsObjects;

					$( "message" ).style.display = "none";
					$( "progressbar" ).style.display = "none";
					$( "start" ).style.display = "block";
					$( "start" ).className = "enabled";

					g_handleUpdate( result, 1 );

				}

				$( "progress" ).style.display = "block";


				var loader = new PhysicsSceneLoader();
				loader.callbackProgress = callbackProgress;
				loader.load( "../../assets/js/scene.js", callbackFinished );


				$( "plus_exp" ).addEventListener( 'click', createToggle( "exp" ), false );

				window.addEventListener( 'resize', g_onWindowResize, false );

			}

			function g_onWindowResize() {

				g_windowHalfX = window.innerWidth / 2;
				g_windowHalfY = window.innerHeight / 2;

				g_camera.aspect = window.innerWidth / window.innerHeight;
				g_camera.updateProjectionMatrix();

				g_renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function g_setButtonActive( id ) {

				$( "start" ).style.backgroundColor = "green";

			}


    
            /**
             * Start g_scene
             * Play physics simulation
             **/
			function g_onStartClick() {

				$( "progress" ).style.display = "none";

				g_camera = g_loaded.currentCamera;
				g_camera.aspect = window.innerWidth / window.innerHeight;
				g_camera.updateProjectionMatrix();

				g_scene = g_loaded.scene;
		        g_scene.setGravity(new THREE.Vector3( 0, -9.8, 0 ));
                console.log("Scene type");
                console.log(g_scene);
		        g_scene.addEventListener(
		        	'update',
		        	function() {
		        		g_scene.simulate( undefined, 1 );
		        		//physics_stats.update();
		        	}
		        );

                /**
                 * Get "ground" g_mesh object, and assign its mass to 0
                 */
                console.log("all objects");
                console.log(g_loaded.objects);
                console.log("physics objects");
                console.log(g_loaded.physicsObjects);
                var axis = new THREE.AxisHelper(20);
                g_scene.add(axis);

                g_scene.remove(g_controls.getObject());
				g_controls = new THREE.PointerLockControls( g_camera );
				g_scene.add( g_controls.getObject() );

				g_ray = new THREE.Raycaster();
				g_ray.ray.direction.set( 0, -1, 0 );
						load_coincoin(g_scene,g_physicsObjects);

                // Run at 60FPS target
		        requestAnimationFrame( g_renderLoadScene );
                // Simulate physics
		        g_scene.simulate();

			}

			function g_onDocumentMouseMove(event) {

				g_mouseX = ( event.clientX - g_windowHalfX );
				g_mouseY = ( event.clientY - g_windowHalfY );

			}

            /**
             * Creates a dummy loading g_scene full of cubes
             */
			function g_createLoadScene() {

				var result = {

					scene:  new THREE.Scene,
					camera: new THREE.PerspectiveCamera( 65, window.innerWidth / window.innerHeight, 1, 1000 )

				};
				result.camera.position.z = 100;

				var object, g_geometry, material, light, count = 500, range = 200;

                /**
                 * Display loading g_scene: loads of random cubes
                 */
				material = new THREE.MeshLambertMaterial( { color:0xffffff } );
				g_geometry = new THREE.CubeGeometry( 5, 5, 5 );

				for( var i = 0; i < count; i++ ) {

					object = new THREE.Mesh( g_geometry, material );

					object.position.x = ( Math.random() - 0.5 ) * range;
					object.position.y = ( Math.random() - 0.5 ) * range;
					object.position.z = ( Math.random() - 0.5 ) * range;

					object.rotation.x = Math.random() * 6;
					object.rotation.y = Math.random() * 6;
					object.rotation.z = Math.random() * 6;

					object.matrixAutoUpdate = false;
					object.updateMatrix();

					result.scene.add( object );

				}

				result.scene.matrixAutoUpdate = false;

				light = new THREE.PointLight( 0xffffff );
				result.scene.add( light );

				light = new THREE.DirectionalLight( 0x111111 );
				light.position.x = 1;
				result.scene.add( light );

				return result;

			}


			function g_animate() {

				requestAnimationFrame( g_animate );

				g_render();
				stats.update();
			}

			function g_renderLoadScene() {
				g_renderer.g_render( scene, g_camera );
			}
            var material = new THREE.LineBasicMaterial({
                    color: 0x0000ff
                });
            var line = {};
			function g_render() {

                /**
                 * Check for nearby objects in view direction 
                 **/
                //console.log(g_closestFunction());

                direction = g_controls.getLookDirection().clone();
                position = g_controls.getPosition().clone();

                g_rayCasting(position.clone(), direction.clone());

                //// Debug direction
                if(g_debug) {
                    var g_geometry = new THREE.Geometry();
                    //g_geometry.vertices.push(new THREE.Vector3(0,0,0));
                    //g_geometry.vertices.push(position.add(direction.multiplyScalar(1000)));
                    g_geometry.vertices.push(position.clone());
                    g_geometry.vertices.push(position.clone().add(direction.clone().multiplyScalar(1000)));
                    g_scene.remove(line);
                    line = new THREE.Line(g_geometry, material);
                    g_scene.add(line);
                }



				g_controls.update( Date.now() - g_time );

				g_time = Date.now();
                
				g_renderer.render( g_scene, g_camera );
				game_sound.update( g_controls );
			}


            function g_closestFunction()
            {
                var closest = {};
                var min = 10000000;
                for(obj in g_physicsObjects) {
                    dist = g_distanceFromObject(g_physicsObjects[obj]);
                    if(dist<min) {
                        min = dist; 
                        closest=obj;
                    }
                }
                return closest;
            }

            /**
             * Returns the distance at which we are form object (in the sense
             of norm2 
             **/
            function g_distanceFromObject(obj) {
                var cubePos= obj.position;
                var cameraPos = g_controls.getObject().position;
                var dist =
                Math.sqrt((cubePos.y-cameraPos.x)*(cubePos.x-cameraPos.x),(cubePos.y-cameraPos.y)*(cubePos.y-cameraPos.y),(cubePos.z-cameraPos.z)*(cubePos.z-cameraPos.z));

                return dist;
            }

            /**
             * Doesn't work
             **/
            function g_rayCasting(origin, direction) {
                g_ray.ray.origin = origin.clone();
                g_ray.ray.direction = direction.clone().normalize();


                for (var m in g_physicsObjects) {
                    var intersects = g_ray.intersectObject( g_physicsObjects[m] );

                    if ( intersects.length > 0 ) {
                        // Normal vector of the meshes' face we hit
                        //var nV = intersects[0].face.normal;
                        // Velocity vector (of the character)
                        //var vV = this.velocity.clone();
                        //// And calculate the reflection vector
                        //var rV = n.multiplyScalar(-2 * vV.dot(nV)).addSelf(vV);;

                        console.log("intersect with "+g_physicsObjects[m].name);
                    }
                }

            }















            /* ================================================================================ 
             * SCENE EXPLORER
             * Just for g_debug purposes
             * This section is used to display all available objects and
             * properties into an html tree
             *  =============================================================================== */

			function toggle( id ) {

				var scn = $( "section_" + id ).style,
					btn = $( "plus_" + id );

				if ( scn.display == "block" ) {

					scn.display = "none";
					btn.innerHTML = "[+]";

				}
				else {

					scn.display = "block";
					btn.innerHTML = "[-]";

				}

			}

			function createToggle( label ) { return function() { toggle( label ) } };

			function refreshSceneView( result ) {

				$( "section_exp" ).innerHTML = generateSceneView( result );

				var config = [ "obj", "geo", "mat", "tex", "lit", "cam" ];

				for ( var i = 0; i < config.length; i++ )
					$( "plus_" + config[i] ).addEventListener( 'click', createToggle( config[i] ), false );

			}

            /**
             * Add objects into HTML tree
             * Just for g_debug purposes
             */
			function generateSection( label, id, objects ) {

				var html = "";

				html += "<h3><a id='plus_" + id + "' href='#'>[+]</a> " + label + "</h3>";
				html += "<div id='section_" + id + "' class='part'>";

				for( var o in objects ) {

					html += o + "<br/>";

				}
				html += "</div>";

				return html;

			}

            /**
             * Add objects into HTML tree
             * Just for g_debug purposes
             */
			function generateSceneView( result ) {

				var config = [
				[ "Objects",    "obj", result.objects ],
				[ "Geometries", "geo", result.geometries ],
				[ "Materials",  "mat", result.materials ],
				[ "Textures",   "tex", result.textures ],
				[ "Lights",     "lit", result.lights ],
				[ "Cameras",    "cam", result.cameras ]
				];

				var html = "";

				for ( var i = 0; i < config.length; i++ )
					html += generateSection( config[i][0], config[i][1], config[i][2] );

				return html;

			}
            /* ================================================================================ 
             * END SCENE EXPLORER
             *  =============================================================================== */

		</script>

	</body>
</html>
